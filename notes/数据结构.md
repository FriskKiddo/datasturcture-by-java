---
title: data structure
date: 2020-09-20 20:50:12
---

# 数据结构

数据结构的分类

- 线性结构
  - 数组，链表，栈，队列，哈希表
- 树形结构
  - 二叉树，B树，堆，`Trie`，哈夫曼树，并查集
- 图形结构
  - 图

------

## 一  线性表

1. 数组
2. 链表
3. 栈
4. 队列

### `ArrayList`

动态数组的特点在于动态的扩容与缩容，底层是通过数组进行存储数据

#### 接口

```java
int size();
boolean isEmpty();
boolean contains(E e);
void clear();
void add(E e);
void add(E e, int index);
E remove(int index);
E get(int index);
E set(E e, int index);
int indexOf(E e);
```

#### 动态容量

动态数组底层通过数组实现，有动态扩容与缩容的方法。

每次添加之前都应该进行动态扩容，每次删除之后都应该进行动态缩容

```java
protected void ensureCapacity(int capacity){
    if (capacity <= elements.length){
        return;
    }
    int newCapacity = capacity << 1;
    E[] oldElements = elements;
    elements = (E[]) new Object[newCapacity];
    for (int i = 0; i < size; i++){
        elements[i] = oldElements[i];
    }
}
protected void trim(){
    int capacity = elements.length;
    if (size < (capacity >> 2) && capacity > DEFAULT_CAPACITY){
        int newCapacity = capacity >> 1;	
        E[] oldElements = elements;
        elements = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++){
            elements[i] = oldElements[i];
        }
    }
}
```

代码实现

```java
public class ArrayList<E> {
    private static final int ELEMENT_NOT_FOUND = -1;
   	private static final int DEFAULT_CAPACITY = 10;
	private E[] elements;
	private int size;
    
    public ArrayList(){
        this(DEFAULT_CAPACITY);
    }
    
    public ArrayList(int capacity){
        elements = (E[]) new E[capacity];
    }
	
	public int size(){
		return size;
	}
	
	public boolean isEmpty(){
		return size==0;
	}
	
	public boolean contains(E e){
		if (e == null){
			for (int i = 0; i <size; i++){
				if (elements[i] == null){
                    return true;
                }
			}
		}else{
            for (int i = 0; i <size; i++){
				if (e.equals(elements[i])){
                    return true;
                }
			}
        }
        return false;
	}
	
	public void clear(){
		for (int i = 0; i < size; i++){
			elements[i] = null;
		}
		size = 0;
	}
    
    public int indexOf(E e){
		if (e == null){
			for (int i = 0; i <size; i++){
				if (elements[i] == null){
                    return i;
                }
			}
		}else{
            for (int i = 0; i <size; i++){
				if (e.equals(elements[i])){
                    return i;
                }
			}
        }
        return ElEMENT_NOT_FOUND;
    }

    public void get(int index){
        rangeCheck(index);
        return elements[index];
	}
    
    public E set(E e, int index){
        rangeCheck(index);
        E oldValue = elements[index];
        elements[index] = e;
        return oldValue;
    }
    
    public void add(E e){
        add(e, size);
    }
    
    public E remove(int index){
        rangeCheck(index);
        E oldValue = elements[index];
        for (int i = index + 1; i < size; i ++){
            elements[i - 1] = elements[i];
        }
        trim();
      	size--;
        return oldValue;
    }
    
    private void add(E e, int index){
        rangeCheckForAdd(index);
        ensureCapacity(index);
        for (int i = size - 1; i >= index; i++){
            elements[i + 1] = elements[i];
        }
        elements[index] = e;
        size++;
    }
    
    protected void ensureCapacity(int capacity){
        if (capacity <= elements.length){
            return;
        }
        int newCapacity = capacity << 1;
        E[] oldElements = elements;
        elements = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++){
            elements[i] = oldElements[i];
        }
    }
    
    protected void trim(){
        int capacity = elements.length;
        if (size < (capacity >> 2) && capacity > DEFAULT_CAPACITY){
	        int newCapacity = capacity >> 1;	
    	    E[] oldElements = elements;
        	elements = (E[]) new Object[newCapacity];
        	for (int i = 0; i < size; i++){
            	elements[i] = oldElements[i];
            }
        }
    }
        
    protected void rangeCheck(int index){
        if (index < 0 || index >= size){
            throw new IlleagalAugumentException("index out of bounds");
        }
    }
    
    protected void rangeCheckForAdd(int index){
        if (index < 0 ||index > size){
            throw new IlleagalAugumentException("index out of bounds");
        }
	}
}
```



### `LinkedList`

与动态数组不同，不需要对结构的规模进行严格管理

可大致分为一下四种：

- 单向链表

- 双向链表

- 单向循环链表

- 双向循环链表

#### 查找

根据查找的索引位置优化查找时间复杂度

```java
private Node<E> node(int index){
    if (index < (size >> 1)){
        Node<E> node = first;
        for (int i = 0; i < index; i++){
            node = node.next;
        }
        return node;  
    } else{
        Node<E> node = last;
        for (int i = size - 1; i > index; i--){
            node = node.prev;
        }
        return node;
    }
}
```

#### 增与删

对于`add`方法考虑**头插入，尾插入，中间插入，空插入**四种情况

```java
//LinkedList的add方法
public void add(E e, int index){
    rangeCheckForAdd(index);
    if(size == index){
        Node<E> oldLast = last;
        last = new Node<>(last, e, null);
        if (oldLast == null){
            first = last;
        }else {
            oldLast.next = last;    
        }
    } else {
        Node<E> next = node(index);
        Node<E> prev = next.prev;
        Node<E> newNode = new Node(prev, e, next);
        next.prev = newNode;
        if (prev == null){
            first = newNode;
        }else{
            prev.next = newNode;
        }
    }
    size++;
}

//CircleLinkedList的add方法
public void add(E e, int index){
	rangeCheckForAdd(index);
	if (size == index){
        Node<E> oldLast = last;
        last = new Node<>(last, e, null);
        if (oldLast == null){
            first = last;
            first.next = last;
            first.prev = last;
        }else{
            oldLast.next = last;
            first.prev = last;
        }
    }else{
        Node<E> next = node(index);
        node<E> prev = next.prev;
        Node<E> newNode = new Node<>(prev, e, next);
        next.prev = newNode;
        prev.next = newNode;
        if (index == 0){
            first = newNode;
        }
    }
    size++;
}
```

对于`remove`方法，不循环的链表考虑前后两个节点的存在性，循环链表考虑链表的长度是否为1

```java
//LinkedList的remove方法
public E remove(int index){
    rangeCheck(index);
    Node<E> node = node(index);
    Node<E> next = node.next;
    Node<E> prev = node.prev;
    if (next == null){
        last = prev;
    }else{
        next.prev = prev;
    }
    if (prev == null){
        first =next;
    }else{
        prev.next = next;
    }
    size--;
    return node.element;
}

//CircleLinkedList的remove方法
public E remove(int index){
	rangeCheck(index);
    Node<E> node = node(index);
    if (size == 1) {
        first = null;
        last = null;
    }else{
        Node<E> next = node.next;
        Node<E> prev = node.prev;
        next.prev = prev;
        prev.next = next;
        if (node == first){
            first = next;
        }
        if (node == last){
            last = prev;
        }
    }
    size--;
    return node.element;
}
```



### `Stack`

在这里我们的栈可以通过`LinkedList`来实现，在链表的末尾进行增删即可实现栈的后进先出的逻辑

```java
public class Stack<E> {
    
    private LinkedList<E> list;
    
    public Stack() {
        list = new LinkedList<>();
    }
    
    public int size() {
        return list.size();
    }
    
    public boolean isEmpty() {
        return list.isEmpty();
    }
    
    public void push(E e) {
        list.add(e);
    }

    public E pop() {
        return list.remove(list.size() - 1);
    }

    public E peek() {
        return list.get(list.size() - 1);
    }
    
}
```



### `Queue`

同样我们可以通过`LinkedList`来实现队列的逻辑

```java
public class Queue<E>{

    private LinkedList<E> list;

    public Queue() {
        list = new LinkedList<>();
    }

    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public void clear() {
        list.clear();
    }

    public void offer(E e) {
        list.add(e);
    }

    public E poll() {
        return list.remove(0);
    }

    public E peek() {
        return list.get(0);
    }
}
```



## 二  树

1. `BinaryTree`
2. `BinarySearchTree`
3. `BalancedBinarySearchTree`
4. `AVLTree`
5. `RBTree`

### `BinaryTree`

#### `Node`类

```java
protected static class Node<E> {
	E element;
	Node<E> parent;
	Node<E> left;
	Node<E> right;
    
    public boolean isLeftChild(){
        return parent != null && this == parent.left;
    }
    
    public boolean isRightChild(){
        return parent !=null && this == parent.right;
    }
    
    public boolean isLeaf(){
        return left == null && right == null;
    }
    
    public boolean hasTwoChildren(){
        return left != null && right != null;
    }
    
    public Node<E> sibling(){
        if (isRightChild){
            return parent.left;
        }
        if (isLeftChild()){
            return parent.right;
        }
        return null;
    }
}

protected Node<E> createNode(E elem, Node<E> parent){
    return new Node<>(elem, parent);
}
```

最简单的二叉树无法完成元素的比较操作，因此只有树的遍历，查找前驱后驱这几种不需要进行元素对比即可完成的操作

```java
public int size();
public boolean isEmpty();
public void clear();
protected void predcessor(Node<E> node); 
protected void successor(Node<E> node);
public void travelPre();
public void travelIn();
public void travelPost();
```

#### 前驱与后驱

```java
protected void predcessor(Node<E> node) {
    
}
protected void successor(Node<E> node) {
    
}
```

#### 迭代版遍历

```java
public void travelPre() {

}

public void travelIn() {

}

public void travelPost() {
    
}

public void travelLevel() {
    
}
```

#### 反转

```java
public void invert(){
	invert(root);
}

private void invert(Node<E> node){
	if(node == null){
		return;
	}
    Node<E> tmp = node.left;
    node.left = node.right;
    node.right = tmp;
    invert(node.left);
    invert(node.right);
}
```



### `BinarySearchTree`

继承自`BinaryTree`在`BinaryTree`基础上增加了`comparator`成员，可以进行添加和删除等需要进行元素对比的操作

节点的左子树所有节点均小于该节点，节点的右子树所有节点均大于该节点

#### 查找

二叉搜索树的查找类似于二分搜索，待搜索节点大于根节点则向右查找，小于根节点则向左查找

```java
private Node<E> node(E e) {
	Node<E> node = root;
    while (node != null){
        int cmp = compare(e, node.element);
        if (cmp == 0) {
            return node;
        } else if(cmp > 0) {
            node = node.right;
        }else {
            node = node.left;
        }
    }
    return node;
}
```

#### 增与删

二叉搜索树的添加需要树的存在性即添加是否是第一个元素

```java
public void add(E e){
	elementNotNullCheck(e);
    if (root == null){
        root = createNode(e, null);  //后续说明
        size++;
        afterAdd(root);  //后续说明
        return;
    } else{
        Node<E> node = root;
        Node<E> parent = null;  //搜索二人组
        while (node != null) {
            parent = node;
            cmp = compare(e, node.element);
            if (cmp > 0) {
                node = node.right;
            } else if (cmp < 0) {
                node = node.left;
            } else {
                //重复值
                node.element = e;
                return;
            }
        }
        Node<E> newNode = createNode(e, parent);
        if (cmp > 0){
            parent.right = newNode;
        }else{
            parent.left = newNode;
        }
        size++;
        afterAdd(newNode);
    }
}
```

二叉搜索树的删除需要考虑树的存在性以及待删除节点的度，其度可分为0，1，2三种情况

```java
public void remove(E e){
	Node<E> node = node(e);
    if(node == null){
        return;
    }
    size--;
    if(node.hasTwoChild()){
        Node<E> pred = predecessor(node);
        node.element = pred.element;
        node = pred;
    }
    //度为2统一化归为其他两类
    Node<E> replacement = node.left == null ? node.right : node.left;
    if(replacement != null){
        replacement.parent = node.parent;
        if(node.parent == null){
            root = replacement;
        }else{
            if(node.isLeftChild()){
                node.parent.left = replacement;
            }else{
                node.parent.right = replacement;
            }
        }
        afterRemove(replacement);  //等效删除的节点为replacement
    }else{
        if(node.parent == null){
            root = null;
        }else{
            if(node.isLeftChild()){
                node.parent.left = null;
            }else{
                node.parent.right = null
            }
        }
        afterRemove(node);
    }
}
```

#### 完全性判断

用于判断一个二叉树是否是一棵完全二叉树

思路是对树进行层序遍历，第一个叶子节点后之后的节点都必须为叶子节点，且不允许出现仅有右子树的情况

```java
public boolean isComplete(){
	if(root == null){
        return false;
    }
    Queue<Node<E>> queue = new LinkedList<>();
    queue.offer(root);
    Node<E> node = null;
    boolean leaf = false;
    while(!queue.isEmpty()){
        node = queue.poll();
        if(leaf && !node.isLeaf()){
            return false;
        }
        if(node.left != null){
            queue.offer(node.left);
        }else if(node.right != null){
            return false;  //节点仅有右子树
        }
        if(node.right != null){
            queue.offer(node.right);
        }else{
            leaf = true;  //无右子树则只可能为叶子
        }
    }
    return true;
}
```



### `AVLTree`

自平衡二叉搜索树比前者增加了左旋和右旋操作，可以通过其左旋与右旋保持平衡因子绝对值不超过1

#### `AVLNode`类

继承`Node`，新增了height属性，扩展了height属性相关的方法

```java
private class AVLNode<E> extends Node<E> {

    int height = 1;  //高度默认为1

    public AVLNode(E element, Node<E> parent) {
        super(element, parent);
    }

    public int balanceFactor() {
        int leftHeight = left == null ? 0 : ((AVLNode<E>) left).height;
        int rightHeight = right == null ? 0 : ((AVLNode<E>) right).height;
        return leftHeight - rightHeight;
    }
	//更新高度
    public void updateHeight() {
        int leftHeight = left == null ? 0 : ((AVLNode<E>) left).height;
        int rightHeight = right == null ? 0 : ((AVLNode<E>) right).height;
        height = 1 + Math.max(leftHeight, rightHeight);
    }

    public Node<E> tallerChild() {
        int leftHeight = left == null ? 0 : ((AVLNode<E>) left).height;
        int rightHeight = right == null ? 0 : ((AVLNode<E>) right).height;
        if (leftHeight > rightHeight) {
            return left;
        } else if (leftHeight < rightHeight) {
            return right;
        }
        return isLeftChild() ? left : right;
    }
}

protected Node<E> createNode(E elem, Node<E> parent){  
    return new AVLNode<>(element, parent);
}
```

#### 高度更新

```java
private void updateHeight(Node<E> node) {
	((AVLNode<E>) node).updateHeigth();
}
```

#### 旋转

根据祖父节点`grand`与孩子节点`parent`和孙子`child`节点之间的位置关系，平衡因子超过1的情况可以分为LL，RR，LR，RL四种

LR通过**左旋`parent`节点**可以转化为LL情况，RL通过**右旋`parent`节点**可以转化为RR情况

LL通过**右旋`grand`节点**使得树回归平衡，RR通过**左旋`grand`节点**使得树回归平衡

```java
//左旋
private void rotateLeft(Node<E> grand){
    Node<E> parent = grand.right;
    Node<E> child = grand.left;
    grand.right = child;
    parent.left = grand;
    afterRotate(grand, parent, child);
}

//右旋
private void rotateRight(Node<E> grand){
    Node<E> parent = grand.left;
    Node<E> child = grand.right;
    grand.left = child;
    parent.right = grand;
    afterRotate(grand, parent, child);
}

//维护参加旋转节点的parent和height属性
private void afterRotate(Node<E> grand, Node<E> parent, Node<E> child) {
    //从上至下更新parent及高节点的lc、rc属性
    parent.parent = grand.parent;
    if(grand.isLeftChild()){
        parent.parent.left = parent;
    }else{
        parent.parent.right = parent;
    }
    grand.parent = parent;
    if(child != null){  //child可能为空，也可能为一颗子树
        child.parent = grand;
    }
    //自下而上更新height，child不受影响
    updateHeight();
    updateHeight();
}
```

#### 自平衡

添加或删除节点可能会导致`AVLTree`失去平衡，因此每次添加和删除节点后需要进行平衡操作

```java
private boolean isBalanced(Node<E> node) {
        return Math.abs(((AVLNode<E>) node).balanceFactor()) <= 1;
}
```

自平衡操作需要判断旋转方案：LL、RR、LR、RL

```java
private void rebalance(Node<E> grand) {
    Node<E> parent = ((AVLNode<E>) grand).tallerChild();
    Node<E> child = ((AVLNode<E>) parent).tallerChild();
    if (parent.isLeftChild()) {
        if (child.isLeftChild()) {
       		rotateRight(grand);
        } else {
        	rotateLeft(parent);
        	rotateRight(grand);
        }
    } else {
        if (child.isLeftChild()) {
            rotateRight(parent);
            rotateLeft(grand);
        } else {
            rotateLeft(grand);
        }
    }
}
```

添加节点后，添加位置祖先节点高度和平衡可能改变，需要**沿着添加位置的parent向上**进行高度更新和自平衡操作，**当某祖先自平衡操作后，后续祖先节点回会到平衡状态**

```java
protected void afterAdd(Node<E> node){
	while((node = node.parent) != null){
        if(isBalanced(node)){
            //更新高度
            updateHeight(node);
        }else{
            reblance(node);
            break;  //平衡操作后退出
        }
    }
}
```

删除节点后， 可能会导致父节点或祖先节点其中一个失衡，但是自平衡过程中，会导致更高层的祖先出现失衡，因此需要沿着删除位置的parent向上进行高度更新和自平衡

```java
public void afterRemove(Node<E> node){
    	while((node = node.parent) != null){
        if(isBalanced(node)){
            //更新高度
            updateHeight(node);
        }else{
            reblance(node);
        }
    }
}
```

### B树

是一种平衡的多路搜索树，多用于文件系统和数据库的实现，特点是一个节点可以存储多个元素，一个m阶B树每个节点至多m-1个元素，至多m个孩子。

#### 性质

m阶B树一个节点存储的元素个数为x，子节点个数为y，需要满足
$$
根节点：1\leq x\leq m-1\\非根节点：ceil(\frac{m}{2})-1 \leq x \leq m-1\\子节点：y=x+1
$$


#### 添加与上溢

B树新添加的元素必定是添加到叶子节点，可能出现叶子节点的元素个数超过限制，就会发生上溢（overflow）

上溢节点的元素个数必定等于m，上溢的解决方法是：

- 取上溢节点最中间元素k，将k位置元素向上与父节点合并，若父节点上溢则继续当前操作

![image-20201107102240783](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107102240783.png)

​		如上4阶B树，再添加10，黄色节点会溢出，将8上溢至红色节点后红色节点溢出，红色节点将4上溢，最终得到

![image-20201107102508071](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107102508071.png)

#### 删除与下溢

若删除元素在叶子节点，直接删除即可；若删除元素在非叶子节点，则通过前驱后驱替换进而删除仍为叶子节点。

叶子节点被删除一个元素后，元素个数可能会低于最低限制，发生下溢
$$
x\geq ceil(\frac{m}{2}) - 1 = min
$$
如果下溢节点临近的兄弟节点，有至少min+1个元素

- 将父节点插入到下溢节点位置，兄弟节点最大元素替代父节点

  ![image-20201107110158998](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107110158998.png)

  如上5阶B树，删除元素18，兄弟节点元素多余，父节点16下溢到删除元素节点，兄弟节点最大元素15替代16，最终得到

  ![image-20201107110341160](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107110341160.png)

如果下溢节点临近兄弟节点只有min个元素

- 将父节点向下与左右子节点合并，如父节点下溢则继续当前操作

  ![image-20201107105451665](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107105451665.png)

  如上5阶B树，min=2，删除节点17后，将发生下溢，兄弟红色节点无多余节点，父节点黄色节点15元素下溢与16合并，根节点9继续下溢与12合并，最终得到

  ![image-20201107105842359](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107105842359.png)

### 红黑树

如Java的`HashMap`底层实现，jdk1.8中为了解决过度哈希冲突所导致的长链表，会将链表转换成红黑树；Linux底层的CFS进程调度算法中，`vruntime`也是利用红黑树进行存储，多路复用技术的`Epoll`的核心结构也是红黑树+双向链表。

红黑树是4阶B树，每一个黑色节点同其红色孩子节点被视作一个4阶B树节点，如图所示（未包含null）

![image-20201107100705733](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107100705733.png)

其等价于

![image-20201107100930660](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107100930660.png)

#### 属性

1. 节点有红色和黑色两种颜色
2. 树根节点为黑色
3. 叶子节点（即null节点）必须为黑色
4. 红节点的子节点必须是黑色（不能出现相连的红节点）
5. 从**任意节点**出发到叶子节点（null节点）的路径上黑节点的个数一致

如图所示

![image-20201107111703058](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107111703058.png)

#### `RBNode`类

```

```



#### 增与删

- 添加（默认添加的节点均为红色）
  - 父节点为黑色----无需处理
  
  - 父节点为红色，grand节点则为黑
    
    - uncle节点为黑色--旋转操作
      
      LL或RR情况下，grand染红，parent染黑，LL则右旋grand，RR则左旋grand
      
      ![image-20201107115048311](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107115048311.png)
      
      ![image-20201107115008679](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107115008679.png)
      
      LR或RL情况下，grand染红，本身染黑，LR则左旋parent再右旋grand，RL则右旋parent再左旋grand
      
      ![image-20201107115125865](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107115125865.png)
      
      ![image-20201107115135741](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107115135741.png)
      
      
      
    - uncle节点为红色----grand上溢
    
      节点uncle和parent染黑独立，grand染红上溢（对上层而言等价于添加新的红色）继续进行添加操作
    
      ![image-20201107115256890](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107115256890.png)
    
      
    
      ![image-20201107113010713](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107113010713.png)

```java
public void add(Node<V> node) {
    if(node.)
}
```

- 删除

  ![image-20201107163034442](C:\Users\FriskKiddo\Desktop\datasturcture-by-java\notes\pics\image-20201107163034442.png)

  - 删除节点为红色----无需处理
  - 删除节点为黑色（父节点颜色不确定）
    - 拥有2个或1个红色叶子节点，进行前后驱替换，转换成删除红色节点

    - 无红色叶子节点
      - 兄弟节点为红色----转换为黑色（兄染黑，父染红，父旋转）

        若删除节点6，做法是9染黑，7染红，7节点左旋转

      - 兄弟节点为黑色
        - 兄弟没有红色子节点 （不可借元素）---- 父节点下溢
          - 父节点为红
          
            如删除节点8，9染黑，12染红，
          
          - 父节点为黑 ---- 递归下溢
          
            兄弟节点染红，则路径上会少一个黑色，因此需要对沿路祖先节点进行下溢。
          
        - 兄弟有红子节点（可借元素），又根据parent、sibling和红子节点的位置分为LL、RR、LR、RL
        
          - LL或RR：兄弟节点继承父节点颜色（父节点颜色不确定），父节点染黑，兄子节点染黑，对父节点进行右旋或左旋
          - LR或RL：兄子节点继承父节点颜色，父节点染黑，依次对兄弟节点和父节点进行左旋右旋或右旋左旋。
        
          如删除节点1

```java
public void remove(Node<V> node){
    
}
```



## 三 堆

### 存储结构

堆通过数组实现，但数据结构逻辑是二叉树，堆的逻辑是父节点大于等于孩子节点即可

```java
public class BinaryHeap<E> {
    private E[] elements;
    private int size;
    private Comparator<E> comparator
    private static final int DEFAULT_CAPACITY = 10;
    
    //修改比较策略可以实现大顶堆和小顶堆
    protected int compare(E e1, E e2) {
        if (comparator != null) {
            return comparator.compare(e1, e2);
        } else {
            return ((Comparable<E>) e1).compareTo(e2);
        }
    }
	
	public BinaryHeap() {
        this(null, null);
    }

    public BinaryHeap(E[] elements) {
        this(null, elements);
    }

    public BinaryHeap(Comparator<E> comparator) {
        this(comparator, null);
        elements = (E[]) new Object[DEFAULT_CAPACITY];
    }
	
    public BinaryHeap(Comparator<E> comparator, E[] elements) {
        super(comparator);
        if (elements == null || elements.length == 0) {
            this.elements = (E[]) new Object[DEFAULT_CAPACITY];
        } else {
            //深拷贝
            int capacity = Math.max(elements.length, DEFAULT_CAPACITY);
            this.elements = (E[]) new Object[capacity];
            for (int i = 0; i < capacity; i++) {
                this.elements[i] = elements[i];
            }
            size = elements.length;
            heapify();  //原地建堆
        }
    }
}
```

### 建堆

自上而下的上滤

```java
public void heapify(){
	for (int i = 0; i < size; i++){
		siftUp(i);
	}
}
```

自下而上的下滤（效率更高）

```java
public void hepify(){
	for (int i = (len >> 1) - 1; i >= 0; i--){  //从最后一个非叶子节点开始
        siftDown(i);
    }
}
```


### 上滤、下滤

```java
public void siftDown(int index){
    int half = elements.length >> 1;  //>=half 为叶子节点
    E element = elements[index];
    while(index < half){  //叶子节点无需下滤
        int childIndex = (index << 1) + 1;
        E child = elements[childIndex];
        int rightChild = childIndex + 1;
        if (rightChild < size && compare(child, elements[rightChild]) < 0){
            childIndex = rightChild;
            child = elements[rightChild];
        }
     	elements[index] = child;	   
        index = childIndex;
    }
    elements[index] = element;
}


public void siftUp(int index){
	E e = elements[index];
    while(index > 0){
        int parentIndex = (index - 1) >> 1;
        E parent = elements[index];
        if (compare(e, parent) > 0){
            elements[index] = parent;
            index = parentIndex;
        }else{
            break;  //当前节点<=父节点立即结束循环
        }
    }
    elements[index] = e;
}
```

## 四 `Set`

### `TreeSet`

### `HashSet`

## 五 `Map`

### `TreeMap`

### `HashMap`



## 六 优先级队列

## 七 `Trie`

字典树`Trie`，主要应用是来确定单词的前缀，如搜索补全，`IP`路由匹配等，是非典型的多叉树模型，树节点的实现形式有数组、Map两种

- 数组实现：每个节点内部维护一个长度为26的数组，对应26个英文字母，在对应位置存放下一节点
- Map实现：每个节点内部维护一个Map，键为Character，值为下一节点

#### Node类

```java
private static class Node<V> {
	Character character;  //删除时作为节点指示
	Node<V> parent;
	V value;
	boolean word = false; //是否是一个单词的结尾
	HashMap<Character,Node<V>> children = new HashMap<>(); 
    
    public Node(Node<V> parent) {
        this.parent = parent;
    }
}
```

节点之间通过`children`实现连接

![](https://pic.leetcode-cn.com/b868689d57a6df77edf94db7a27cae32feb06f6b3d229ad5702fd582cd8c90da-image-20200722205303327.png)

接口设计

```java
public int size();
public boolean contains(String s);
public void clear();
public V add(String key, V v);
public V get(String key);
public V remove(String key);
public boolean startWith(String prefix);  //是否存在prefix前缀的字符串
```

关键代码实现

```java
public V add(String key, V v){
	if (root == null){
        root = new Node<>(null)
    }
    Node<V> node = root;
    int len = key.length();
    for (int i = 0; i < len; i++){
        char c = key.charAt(i);
        //对应位置是否有子节点
        Node<V> childNode = node.children.get(c);
        if (childNode == null){
            childNode = new Node<V>(node);
            node.children.put(c, childNode);
            childNode.character = c;
        }
        node = childNode;
    }
    //字符遍历结束后判断
    if (node.word){
        V old = node.value;
        node.value = v;
        return old;            
    } else{
        node.word = true;  //新增单词
        node.value = v;
        size++;
        return null;
    }
}

public V remove(String key){
    //从尾部开始
    Node<V> node = node(key);
    V old = node.value;
    if (node == null || !node.key){
        return null;
	}
    size--;
    //还有子节点
    if (!node.children.isEmpty){
        node.word = false;
        node.value = null;
        return old;
    } else {
        //向上删除
        Node<V> parent;
        while((parent = node.parent) != null){
            parent.children.remove(node.character);
            if (parent.word || !parent.children.isEmpty()){
                break;
            }
            node = parent;
        }
    }
	return old;
}

private Node<V> node(String key){
    int len = key.length();
    Node<V> node = root;
    for (int i = 0; i < len; i++){
        char c = key.charAt(i);
        if (node == null ){
            return null;
        }
        node = node.children.get(c);
    }
    return node.word ? node : null;
}
```



## 八 并查集

并查集(`Union Find`)

需求分析：假设有n个村庄，有些粗壮之间有连接的路， 有些村庄之间并没有连接的路。

设计一个数据结构能够快速执行2个操作：

1. 查询2个村庄之间是否有连接的路
2. 连接2个村庄

通过数组，链表，平衡二叉树，集合，时间复杂度都是O(n)，并查集能够保证查询，连接的均摊复杂度是O(a*n)

并查集有2个核心操作：

1. 查找：查找元素所在集合
2. 合并：将两个元素所在集合合并为一个集合

两种思想思路：

1. `Quick Find`

   查找时间复杂度O(1)，合并时间复杂度O(n)

2. `Quick Union`

   时间复杂度O(nlogn)，可优化至O(a*n)

并查集是数组实现的树形结果（同二叉堆和优先级队列）

<img src="https://images0.cnblogs.com/blog/358550/201309/12160744-00b6e27da65b4b48b903e768a97bf888.png"  />

接口定义

```java
//查找所属集合根节点
int find(int v);
//合并v1 v2所属集合
void union(int v1, int v2);
//v1 v2 是否属于同一集合
boolean isSame(int v1, int v2);
```

初始化

初始化时，每个元素各自属于一个单元素集合

![](https://images0.cnblogs.com/blog/358550/201309/12160852-98560aa5c6764feeab476938d1bcfe24.png)

```java
public class UnionFind{
    private int[] parents;
    public UnionFind(int capacity){
        if (capacity < 0){
            throw new IllegalArugumentException("capacity must >=1.");
        }
        parents = new int[capacity];
        for (int i = 0; i < capacity; i++){
            parents[i] = i;
        }
    }
}
```

### `Quick Find`

```java
public int find(int v){
	rangeCheck(v);
	return parents[v];  //父节点就是根节点
}
//将v1所在集合所有节点都指向v2的父节点
public void union(int v1, int v2){
    int p1 = find(v1);
    int p2 = find(v2);
    if (p1 == p2){
        return;
    }
    for (int i = 0; i < parents.length; i++){
        if (parents[i] == p1){
            parents[i] = p2;
        }
    }
}

public boolean isSame(int v1, int v2){
    return find(v1) == find(v2);
}
```

### `Quick Union`

```java
//根节点向上找
public int find(int v){
    rangeCheck(v);
    while(v != parents[v]){  //向上找，直到父节点为本身
        v = parents[v];
    }
    return v;
}

//将v1的根节点指向改成v2的父节点
public void union(int v1, int v2){
    int p1 = find(v1);
    int p2 = find(v2); 
    if (p1 == p2){
        return;
    }
    parents[p1] = p2;
}

public boolean isSame(int v1, int v2){
    return find(v1) == find(v2);
}
```

### 并查集优化

根据`Quick union`过程中，可能出现树不平衡的情况，甚至退化成链表，才需不同方案进行优化

1. 基于`size`的优化：元素少的树嫁接到元素多的树

   仍会出现树不平衡的情况，不使用

2. 基于`rank`的优化：矮的树嫁接到高的树

   ```java
   private int[] ranks;
   
   public UnionFind(int capacicty){
   	super(capacity);
       ranks = new int[capacity];
       for (int i = 0; i < ranks.length; i++) {
       	ranks[i] = 1;
       }
   }
   
   public void union(int v1, int v2){
       int p1 = find(v1);
       int p2 = find(v2);
       if (p1 == p2){
           return;
       }
       if (ranks[p1] > ranks[p2]){
           parents[p2] = p1;
       }else if (ranks[p1] < ranks[p2]){
           parents[p1] = p2;
       }else{
           parents[p1] = p2;
           ranks[p2]++;
       }
   }
   
   ```

3. 路径压缩（`Path Compression`）的优化

   随着`union`次数的增多，树的高度依然会越来越高，导致`find`操作变慢，尤其是底层节点

   路径压缩：在`find`时使路径上的所有节点都指向根节点，实现成本稍高
   
   ```java
   public void find(int v){
   	rangeCheck(v);
       while(v != parents[v]){
           parents[v] = find(parents[v]);
       }
       return parents[v];
   }
   ```
   
4. 路径分裂（`Path splitting`）

   路径分裂：使路径上的每个节点都指向祖父节点

   ```java
   public void find(int v){
       rangeCheck(v);
       while(v != parents[v]){
           int p = parents[v];
           parents[v] = parents[p];
           v = p;
       }
       return v;
   }
   ```

   

5. 路径减半（`Path Halving`）

   使路径上每隔一个节点就指向其祖父节点

   ```java
   public void find(int v){
       rangeCheck(v);
       while(v != parents[v]){
           parents[v] = parents[parents[v]];
           v = parents[v];
       }
   }
   ```

   > 并查集选择：Using both path compression, splitting, or halving and union by rank or size ensures that the amortized time per operation is only O(α(n)).
   >
   > Quick union + rank + halving/splitting

### 并查集的泛型

通过链表+映射实现支持泛型的并查集

```java
public class GenericUnionFind<V> {

    private Map<V, Node<V>> nodes = new HashMap<>();

    private static class Node<V> {
        V value;
        Node<V> parent = this;
        int rank = 1;

        public Node(V value) {
            this.value = value;
        }
    }

    public void makeSet(V v) {
        if (nodes.containsKey(v)) {
            return;
        }
        nodes.put(v, new Node<>(v));
    }

    public V find(V v) {
        Node<V> node = findNode(v);
        return node == null ? null : node.value;
    }

    public void union(V v1, V v2) {
        Node<V> p1 = findNode(v1);
        Node<V> p2 = findNode(v2);
        if (Objects.equals(p1.value, p2.value)) {
            return;
        }
        if (p1.rank > p2.rank) {
            p2.parent = p1;
        } else if (p1.rank < p2.rank) {
            p1.parent = p2;
        } else {
            p1.parent = p2;
            p2.rank++;
        }
    }

    public boolean isSame(V v1, V v2) {
        return Objects.equals(find(v1), find(v2));
    }

    /**
     * 查询v的根节点
     * @param v
     * @return
     */
    private Node<V> findNode(V v) {
        Node<V> node = nodes.get(v);
        if (node == null) {
            return null;
        }
        while(!Objects.equals(node.value, node.parent.value)){
            node.parent = node.parent.parent;
            node = node.parent;
        }
        return node;
    }

}
```

## 九 图（`Graph`）

图由顶点（`vertex`）和边（`edge`）组成，通常表示为`G =（V，E）`

简单图：没有平行边和自环的图

连通图：任意2个顶点均连通的无向图

强连通图：任意2个顶点均连通的有向图

连通分量：无向图的极大连通子图

强连通分量：有向图的极大连通子图

### 实现方案

- 邻接矩阵

  一维数组存放顶点信息，二维数组存放边信息

-  邻接表（采取此实现方案）

  一维数组存放链表，每个链表代表边信息

1. 图的接口设计

   ```java
   void addVertex(V v);
   
   void addEdge(V from, V to);
   
   void addEdge(V from, V to, E weight);
   
   void removeVertex(V v);
   
   void removeEdge(V from, V to);
   
   int edgesSize();
   
   int verticesSize();
   ```

2. 图的存储形式

   ```java
   //存储V与顶点的对应关系
   private Map<V, Vertex<V, E>> vertices = new HashMap<>();
   //存储所有边
   private Set<Edge<V, E>> edges = new HashSet<>();
   //内部顶点类
   private static class Vertex<V, E> {
       V value;
       Set<Edge<V, E>> inEdges = new HashSet<>();
       Set<Edge<V, E>> outEdges = new HashSet<>();
   
       public Vertex(V value) {
           this.value = value;
       }
   
       @Override
       public boolean equals(Object o) {
           if (this == o) {
               return true;
           }
           if (o == null || getClass() != o.getClass()) {
               return false;
           }
           Vertex<?, ?> vertex = (Vertex<?, ?>) o;
           return Objects.equals(value, vertex.value);
       }
   
       @Override
       public int hashCode() {
           return Objects.hash(value);
       }
   }
   //内部边类
   private static class Edge<V, E> {
       Vertex<V, E> from;
       Vertex<V, E> to;
       E weight;
   
       public Edge(Vertex<V, E> from, Vertex<V, E> to) {
           this.from = from;
           this.to = to;
       }
   
       @Override
       public boolean equals(Object o) {
           if (this == o) {
               return true;
           }
           if (o == null || getClass() != o.getClass()) {
               return false;
           }
           Edge<?, ?> edge1 = (Edge<?, ?>) o;
           return Objects.equals(from, edge1.from) &&
               Objects.equals(to, edge1.to);
       }
   
       @Override
       public int hashCode() {
           return Objects.hash(from, to);
       }
   }
   ```

3. 关键函数实现

   ```java
   public void addVertex(V v){
       if (vertices.containsKey(v)){
           return;
       }
       vertices.put(v,new Vertex<>(v));
   }
   
   
   
   
   ```

### 图的遍历

- 深度优先遍历（`DFS`）

  ​	访问一个顶点后 

- 广度优先遍历（`BFS`)

  ​	起始顶点入队，访问顶点后遍历其指向的所有未访问顶点并加入队列中。

> ​	二叉树层序遍历是一种BFS，前序遍历是DFS

- 代码实现

  ```java
  public void bfs(V begin){
  	Vertex<V, E> beginVertex = vertices.get(begin);
      if (beginVertex == null) {
          return;
      }
      Set<Vertex<V, E>> visitedVertex = new HashSet<>();
      Queue<Vertex<V, E>> queue = new LinkedList<>();
  	queue.offer(beginVertex);
      visitedVertex.add(beginVertex);
      while(!visitedVertex.isEmpty){
          Vertex<V,E> vertex = queue.poll;
          System.out.println(vertex.value);
          for (Edge<V,E> edge : vertex.outEdge){
  	        if (!visitedVertex.contains(edge.to)){
                  queue.offer(edge.to);
                  visitedVertex.add(edge.to);
              }
          }
      }
  }
  
  public void dfs(V begin) {
  	Vertex<V,E> beginVertex = vertices.get(begin);
      if (beginVertex == null){
          return;
      }
      Set<Vertex<V,E>> visitedVertex = new HashSet<>();
      dfs(beginVertex, visitedVertex);
  }
  
  private void dfs(Vertex<V, E> vertex, Set<Vertex<V, E>> visitedVertex) {
  	System.out.println(vertex.value);
      visitedVertex.add(vertex);
      for (Edge<V,E> edge : vertex.outEdge){
          if (!visitedVertex.contains(edge.to)){
              dfs(edge.to, visitedVertex);
          }
      }
  }
  
  //非递归形式
    public void dfs2(V begin){
        Vertex<V,E> beginVertex = vertices.get(begin);
        if (beginVertex == null){
            return;
        }
        
    }
  
  ```
  
  
  标准的`AOV`网是一个有向无环图

### 拓扑排序

前驱活动：有向边起点的活动称为终点的前驱活动

只有当一个活动的前驱全部都完成后，这个活动才能进行

后继活动：有向边终点的活动称为起点的后继活动

卡恩算法：

​	假设L是存放拓扑排序结果的列表：    

1. 将所有入度为0的顶点放入L中，然后把这些顶点从图中去掉
2. 重复操作1，直到找不到入度为0的顶点
3. 若L中的元素与顶点总数相同，说明排序成功；否则说明图中有环

```java
public List<V> topologicalSort(){
    List<Vertex<V,E>> list = new ArrayList<>();
    Queue<Vertex<V,E>> queue = new LinkedList<>();  //临时存放顶点
    Map<Vertex<V,E>, Integer>> ins = new HashMap<>();  //存放顶点入度
    vertices.forEach((V key, Vertex<V,E> vertex) -> {
        int in = vertex.inEdges.size();
        if (in == 0){
            queue.offer(vertex);
        }else{
            ins.put(vertex, in);
        }
    });
    while(!queue.isEmpty()){
        Vertex<V,E> vertex = queue.poll();
        list.add(Vertex.value);
        for(Edge<V,E> edge : vertex.outEdges){
            Vertex<V,E> toVertex = edge.to;
            int newIn = ins.get(toVertex) - 1;
            if (newIn == 0){
                queue.offer(toVertex);
            }else{
                ins.put(toVertex, newIn);
            }
        }
    }
    return list;
}
```

### 最小生成树

生成树：即连通图的极小连通子图，它含有图中n个顶点，恰好只有n-1条边

最小生成树：总权值最小的生成树

应用：城市之间光缆布设

切分定理：给定任意切分，横切边中权值最小的边必然属于最小生成树

`Prim`算法 

​	假设G=(V,E)是有权的连通图（无向），A是G中最小生成树的边集

​	算法从`s={u0}`，A为空，重复执行下述操作，直到S=V为止

​	找到切分`C=(S, V-S)`的最小横切边`(u0, v0)`并入集合A，同时将v0并入集合S中

```java
public void prim(){
    
}
```

`Kruskal`算法

​	按照边的权重顺序（从小到大）将边加入生成树种，直到生成树种含有V-1条边为止

```java
public void kruskal(){
    
}
```

### 最短路径

最短路径是指两顶点之间权值之和最小的路径（有向图，无向图，有权图，无权图均适用，不能有负权环，允许有负权边）

无权图相当于是全部权值为1的有权图

求解最短路径的3个经典算法：

- 单源最短路径

  1. `Dijkstra`

     不支持负权边

     时间复杂度：可优化至`O(ElogV)`，E是边数量，V是节点数量

     松弛操作（Relaxation）：更新源点到另一个点的最短路径

  2. `Bellman-Ford`

     支持负权边，可以检测负权环

     算法原理：对所有的边进行V-1次松弛操作，得到所有可能的最短路径

     时间复杂度：`O(EV)`

- 多源最短路径（可求出任意两个顶点之间的最短路径）

  1. `Floyd`

     支持负权边

     算法原理：

     - 从任意顶点`i`到顶点`j`的最短路径不外乎两种可能
       1. 直接从`i`到`j`
       2. 从`i`经过若干点到`j`
     - 假设`dist(i,j)`为顶点`i`到顶点`j`的最短路径
     - 对于每一个顶点`k`，检查`dist(i, k) + dist(k, j) < dist(i, j)`是否成立
       - 如果成立，设置`dist(i, j) = dist(i, k) + dist(k, j)`
     - 当我们遍历完所有节点k，`dist(i, J)`种记录的便是`i`到`j`的最短路径的距离

     时间复杂度：`O(V^3)`，效率高度`Dijkstra`

```java

```

## 十 布隆过滤器

使用场景：

​	如果要经常判断一个元素是否存在？如网络爬虫去爬10亿个网站数据，为了避免爬到重复的网站，如何判断某个网站是否爬过？

​	可以使用`HashSet`和`HashMap`，将元素作为key查找，时间复杂度O(1)，但空间利用率不高，需要占用较多的内存资源

`Bloom Filter`：

​	时间复杂度低，占用内存较少的解决方案，是一个空间效率较高的概率型数据结构，可以来判断一个元素一定不存在或可能存在

​	实质上是一个很长的二进制向量和一些列随机映射函数（Hash函数）

- 优点：空间效率，查询效率远高于一般算法
- 缺点：有一定的误判率，删除困难
- 常见应用：网页黑名单系统、垃圾邮件过滤系统、爬虫网站判重系统、解决缓存穿透问题

原理：

​	假设布隆过滤器为20位二进制、3个哈希函数组成、每个元素经过哈希函数处理都能生成一个索引位置

​	添加元素：将每一个哈希函数生成的索引位置都设为1

​	查询元素：如果有一个哈希函数生成的索引位置不为1，就代表不存在；都为1，就代表存在（一定误判率）

​	时间复杂度：O(k)，k是哈希函数个数

​	空间复杂度：O(m)，m是二进制位数

误判率：

​	误判率p受三个因素影响：二进制位的个数m，哈希函数的个数k，数据规模n
$$
p=（1-e^\frac{k(n+0.5)}{m-1}）^k
$$
​	已知误判率p，数据规模n，求二进制位数m和哈希函数k

## 十一 跳表

有序链表的搜索，删除，添加的平均时间复杂度为O(n)

能否利用二分搜索优化有序链表，让其上述操作时间复杂度降至O(logn)

跳表，在有序链表的基础上添加“跳跃“的操作，设计初衷是取代跳表

`Redis`的`SortedSet`，`LevelDB`的`MenTable`都用到跳表

跳表的搜索

1. 从链表的首元素开始，从左向右搜索，直到找到一个大于或等于目标的元素，或者到达当前层链表的尾部
2. 如果该元素等于目标元素，表明元素被找到
3. 如果如果该元素大于目标元素或已到达链表尾部，则退回到当前层的前一个元素，再转到下一层搜索

跳表的添加

​	细节：随机决定添加元素的层数

跳表的删除

​	细节：删除一个节点后，整个跳表的层数可能降低

跳表的层数

​	跳表是按层构造，底层是一个有序链表

​	第`i`层的元素按某个固定的概率`P`（1/4或者1/2）出现在`i+1`层中

​	元素层数为1的概率是1-P

​	一个元素的平均元素为1/(1-P)

跳表的时间复杂度：

​	O(logn)

## 十二 B+树

MySQL的索引是基于B+树实现的

​	为了减小IO操作数量，一般把一个节点的大小设为最小读取单位

​	MySQL的存储引擎`InnoDB`的最小读取单位为16k

​	相对于B树的优势：

1. 每个节点存储的key数量更多，树的高度更低
2. 所有的数据存储在叶子节点，查询都要查到叶子节点，查询速度稳定
3. 所有叶子节点构成有序链表，区间查询方便

B+树特点：

- 节点分为内部节点和叶子节点
  - 内部节点只存储key，不存储数据
  - 叶子节点存储key和数据

m阶B+树非根节点的元素数量x：[m/2]<= x <= m

B*树是B+树的变体：在内部节点增加一个指向兄弟节点的指针

m阶B*树非根节点的元素数量x：[2m/3]<= x <= m